# 翻书问题或者走台阶问题：
- 共有n个台阶，每次只能上1个台阶或者2个台阶，共有多少种方法爬完台阶。
- 共有n页书，每次只能翻1页或者2页书，共有多少种方法翻完全书。

```py
# f(n)为翻完全书的方法
# 递归写法
def f(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    if n > 2:
        return f(n - 1) + f(n - 2)

# 迭代写法，或者叫循环写法
def f(n):
    res = [0 for i in range(n + 1)]
    res[1] = 1
    res[2] = 2
    for i in range(3, n+1):
        res[i] = res[i - 1] + res[i - 2]
    return res[n]
    
# 使用缓存
res = [0 for i in range(n + 1)]
def f(n):
    if n == 1:
        res[1] = 1
        return 1
    if n == 2:
        res[2] = 2
        return 2
    if n > 2:
        res[n - 1] = f(n - 1)
        res[n - 2] = f(n - 2)
        return res[n - 1] + res[n - 2]
            
```

# 二分查找

```py
def LinearSearch(array, t):
    for i in range(len(array)):
        if array[i] == t:
            return True
    return False


def BinarySearch(array, t):
    left = 0
    right = len(array) - 1
    while left < right:
        mid = int((left + right) / 2)
        if array[mid] < t:
            left = mid + 1
        elif array[mid] > t:
            right = mid - 1
        else:
            return True
    return False


array = list(range(100000000))


import time

t1 = time.time()
LinearSearch(array, 100000001)
t2 = time.time()
print('线性查找：', t2 - t1)

t3 = time.time()
BinarySearch(array, 100000001)
t4 = time.time()
print('二分查找：', t4 - t3)
```

## 二分查找例题（变种）

### 题意

```py
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]

查找比如16在不在矩阵中。
```

### 解法
```py
class Solution:
    # @param matrix, a list of lists of integers
    # @param target, an integer
    # @return a boolean
    def searchMatrix(self, matrix, target):
        i = 0
        j = len(matrix[0]) - 1
        while i < len(matrix) and j >= 0:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] > target:
                j -= 1
            else:
                i += 1
        return False
```

# 链表

链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png)

## python代码

```py
# 链表中的节点的数据结构
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

# 实例化
A = ListNode('a')
B = ListNode('b')
C = ListNode('c')
A.next = B
B.next = C

# 这样，一条链表就形成了。
# 'a' -> 'b' -> 'c'

# 遍历链表
tmp = A
while tmp != None:
    print(tmp.val)
    tmp = tmp.next
```

## 例题

翻转一条单向链表。

例子：

```
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
```

解答：

```py
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        dummy = head
        tmp = dummy
        
        while head and head.next != None:
            dummy = head.next
            head.next = dummy.next
            dummy.next = tmp
            tmp = dummy
        return dummy
        
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

solution = Solution()
reverse_head = solution.reverseList(head)
tmp = reverse_head
while tmp:
    print(tmp.val)
    tmp = tmp.next
```

# 二叉树

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/384px-Binary_tree.svg.png)

## python代码

```py
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)

# root就是一颗二叉树
```

## 中序遍历(先遍历左子树，再遍历根节点，再遍历右子树)

```py
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

def inorder(root):
    if root:
        inorder(root.left)
        print(root.val)
        inorder(root.right)
```

## 前序遍历(先遍历根节点，再遍历左子树，再遍历右子树)

```py
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

def preorder(root):
    if root:
        print(root.val)
        preorder(root.left)
        preorder(root.right)        
```

## 后序遍历(先遍历左子树，再遍历右子树，再遍历根节点)

```py
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

def postorder(root):
    if root:
        postorder(root.left)
        postorder(root.right)
        print(root.val)
```

## 已知一颗二叉树的先序遍历序列为ABCDEFG，中序遍历为CDBAEGF，能否唯一确定一颗二叉树？如果可以，请画出这颗二叉树。

```
            A
           / \
          B   E
         /     \
        C       F
         \     /
          D   G

    先序遍历: ABCDEFG
    中序遍历: CDBAEGF
    后序遍历: DCBGFEA
```

# 栈和队列

## 栈

![](pics/1_4Pn00ch_p4DTCb4r3naCDQ.png)

python实现

```py
class Stack:
    def __init__(self):
        self.stack = []
    def pop(self):
        if self.is_empty():
            return None
        else:
            return self.stack.pop()
    def push(self,val):
        return self.stack.append(val)
    def peak(self):
        if self.is_empty():
            return None
        else:
            return self.stack[-1]
    def size(self):
        return len(self.stack)
    def is_empty(self):
        return self.size() == 0
```

## 队列

![](pics/1_FwL7mJ4qpQWZnommC5tsFQ.png)

python实现

```py
class Queue:
    def __init__(self):
        self.queue = []
    def enqueue(self,val):
        self.queue.insert(0,val)
    def dequeue(self):
        if self.is_empty():
            return None
        else:
            return self.queue.pop()
    def size(self):
        return len(self.queue)
    def is_empty(self):
        return self.size() == 0
```
